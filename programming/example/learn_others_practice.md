# 学习别人的经验和体会

## 值得我学习的程序员或工程师

- 陈皓
- 刘未鹏
- 轮子哥
- tk教主
- 四哥
- 邹欣
- milo yip
- 徐宥
- 云风
- 侯捷
- 阮一峰

## 陈皓

### [对技术的态度][10]

我十年前在上海的时候，给交通银行做项目的时候，
每周休息一天，早九点到晚十点，每天工作12个小时，这样的工作持续了一整年，没有节假日，项目上的技术也没什么意思。
当时我晚上十点回到住处，还想学一些C++/Java和Unix/Windows的技术，于是就看书到晚上11:30，
每天如此，一年下来学到很多东西，时间没有荒废，心里就很开心。
我觉得当时是快乐的，因为有成长的感觉是快乐的。

现在的我，工作、写博客、养孩子，事情其实更多。
我早上7:30起床，会浏览一下国外的新闻，hacker news, tech church, reddit, highavailability之类的站点，9点上班。
晚上6、7点钟下班，开始带孩子。
十点钟孩子睡了觉，我会开始重新细读一下这一天都发生了些什么事情。这个时间也有可能会用来看书。
学习的过程（我）是不喜欢被打断的，所以从十点到十二点，家人都睡了，这正是我连续学习的好时间。
可能从晚上11:30开始，我会做点笔记或者写博客。
我现在对酷壳文章的质量要求比较高一些，所以大概积累一个星期的时间才可以生成一篇文章。
每天我大概都在一两点钟才会睡觉。没办法，我有技术焦虑症。但是觉得这样的生活很充实，也很踏实。

### [谈谈职业规划——CSDN对我的采访][10]

## 刘未鹏

### [怎样才算优秀的程序员][1]

1. 你是否经常关心新技术的进展。（细分：Amazon上的新书，Reddit上的新话题，国外著名技术博客，以及你所专注的技术领域最大的社区的动静）
2. 你是否每两个月阅读一本好的技术书籍。（你是怎样判断一本技术书籍值不值得读的？）
3. 你是否经常查Wikipedia。
4. 你是否阅读《Code Complete》，《The Pragmatic Programmer》 （大家继续补充）
5. 你在编写代码的时候是否关心可读性，可维护性，还只是实现功能便万事大吉。
6. 你经常阅读别人的代码吗？（开源库？）你会阅读自己以前写的代码吗？
7. 你有过花上半天甚至一天时间苦思冥想一个问题最终想出答案的经历吗。（比如 debug。）
8. 你怎么度过大学生活的？
9. 你在你所关注的技术领域的最大社区发过帖子吗？参与过讨论吗？
10. 遇到问题你一般是怎么解决的？
11. 身在这个领域，你感到总是有新的乐趣和挑战吗？

## 轮子哥

### [伴随我成长的编程书][2]

由于之前用很愚蠢的方法写了个Pascal脚本的缘故，看《龙书》之后很容易就理解了里面各种精妙的算法在工程上的好处。
我之前的作法是先用扫描的方法切下一个一个的token，然后做一个递归来递归去复杂到自己都没法看的一遍扫描生成简单指令的方法来做。
程序写出来之后我当场就已经看不懂了。
自从看了《龙书》之后，我才知道这些过程可以用token和语法树来对算法之间进行解耦。

原本学习的汇编也好，VB、Delphi和C++也好，都是同一类的编程语言。这导致我在相当长的时间里面都误以为编程就差不多是这个样子。
直到我看到了《程序设计语言——实践之路》。这本书告诉我，这个世界上除了命令是语言，还有各种不同的编程的范式和方法。
于是借着这本书的机会，我了解到世界上还有Prolog、Erlang和Haskell这么美妙的语言。

Haskell颠覆了我的世界观，让我第一次知道，原来代码也是可以推导的。
说实话我用Haskell用的并不熟，而且我也没写过多少个Haskell的大程序，但是Haskell的很多方面我都去花了很长时间去了解，譬如那个著名的Monad。
多亏了当时搞明白了Monad，我借助这方面的知识，理解了《Monadic Parser Combinator》这篇论文，还看懂ajoo那篇著名的面向组合子编程系列。

上面所列出来的书，每一本都是对我有深刻的影响的。
当然光有深刻的影响是不够的，具体的领域的知识，还是需要更多的资料来深入研究，
譬如说下面的一个单子，就是我在学习开发编译器和虚拟机的时候所看过的。内容都很深刻，很适合消磨时间。
在这里我要感谢g9yuayon同学，他在我需要开阔眼界的时候，给我提供了大量的资料，让我得以快速成长，功不可没。

### [进入2012 -- 回顾我走过的编程之路][4]

过往的这些事情给了我很多的启示。
在程序员的生涯里面，最重要的就是保持对编程的热情，不要被生活的琐事所磨灭。
其次是要给自己 **不断地创造一些足够困难但是又有办法完成的挑战**，这样才可以总是让自己保持着一个快速前进的状态。

## TombKeeper

### [TombKeeper谈如何学习Windows][6]

我很天真地把自己的经验告诉他们：

一、先把Windows的帮助文件从头到尾看一遍。
二、在Windows目录下搜索\*.txt、\*.htm?、\*.log、\*.ini，把每一个文件内容都看一遍。
三、把注册表浏览一遍。

我很奇怪，我看Windows的帮助文件就像看金庸小说一样愉快，怎么会有人觉得辛苦？

两天在家，在笔记本上折腾Linux，遇到了很多问题，
我就把内核每一个编译选项的说明都细细看了一遍，反复编译上二十多遍——然后，所有问题的答案都找到了。
显然，学Linux和学Windows的方法并没有什么不同。

### [图灵访谈：专访TK教主于旸][7]

王尔德说：“教育是令人羡慕的东西，但要记住：凡是值得知道的，没有一个是能够教会的。”
我见过很多出色的研究者，发现大家有一些共有的特征，包括想象力、观察力、好奇心、联想能力，等等。
同时，我也见过一些技术底子好又努力的人，但没有做出比较好的成就，而他们的共性就是缺乏前面说的那些特征。
所以这算是我的一点个人主观经验。

另外，我也不属于有很强的开疆扩土、建功立业欲望的人，很多热衷于技术研究的人都不是。
**我这么多年来一直每天工作 12 个小时**，不是为任何人拼命，只是我自己想去做那些事而已。

我以前自学的时候，不知该看什么，就把书店里相关的书都买了。
但现在安全类书太多了，有钱全买也没时间全看。
但我仍然建议，如果你不确定一本书是不是该买，那就宁可错买，不可错过。
如果买回来，翻了几页发现不好，只能拿来垫显示器，也不过损失几十元。
但如果买对了，一本好书带来的益处将是无比巨大的。

读计算机技术类的书，最重要的是不能光抱着书读，得动手跟着做。

### [tk 谈师傅带徒弟或自学的方法][8]

学校教育的方式是：由浅入深，先理论再实践，多门基础课一起平面推进。
这种方式的好处是学得扎实，适合批量培养人。缺点是出活儿慢，没有利用人的内驱力。

师傅带徒弟或者自学的情况下就不一定要按批量教学的方式来。

我个人的经验是 **不管会不会，先动手搞起来**。
而且不搞太入门的，要**难度中等**，这样才有成就感，能形成正反馈，调动内驱力。
过程中会遇到很多不懂的东西，没关系， **遇到什么就去学什么**。
这个阶段 **不求多求全，以把手头的东西搞起来为目标**。
搞成了再设定一个更难的新目标。
新老目标之间要有继承性。
最后等高难度目标也能搞定了，再转过头系统性地去看看相关技术资料，加固一下地基。

### [tk 谈如何系统学习逆向][9]

我也是先学WEB后学逆向的。从我的经验看，首先应该抛弃“系统的学习”这个想法。
因为逆向需要用人的自然语言逻辑去适应程序的机器指令逻辑，痛苦指数比较高。
要拮抗这个痛苦，需要持续有正反馈。
但“系统的学习”相对难以持续提供正反馈。

所以比较好的方式是 **给自己找一些难度中等，又比较有意思的目标来入手**，比如给 notepad.exe 的菜单里增加一个功能。
在这个入手过程中，先不用想系统不系统的问题，搞到哪儿算哪儿。
入手之后，完成了最痛苦的那个门槛翻越，后面就和学别的差不多了。

## 沈沉舟

### [你尽力了吗？][5]

W.Richard.Stevens的UNP我算是认真看过加了不少旁注，APUE就没有那么认真了，而卷II的一半认真看过，写过读书笔记，卷III就没有看一页。
道格拉斯的卷I、卷III（注：Douglas E.Comer，《用TCP\IP进行网际互联》）是认真看过几遍，卷II就只断续看过。
而很多技术文章，如果搞到手了就懒得再看，却不知道这浪费了多少资源，忽略了多少资源。

如果你连《Windows NT设备驱动程序编写》、《 win9x系统编程》都没有看过，却要写个什么隐藏自己的木马，搞笑。
如果你看都不看汇编语言，偏要问exploit code的原理，那我无法回答也不想回答你。

Unix的man手册你要都看完了，想不会Unix都不行了。
微软的MSDN、Platform SDK DOC你要看完了，你想把Win编程想象得稍微困难点都找不到理由。

还是那句话，一个程序员做到W.Richard.Stevens那个份上，做到逝世后还能叫全世界的顶级hacker们专门著文怀念，但生前却不曾著文攻击，
想想看，那是一种什么样的境界，那是一份什么样的淡然。

## 邹欣

### [驽马的自白][3]

微软工作的确比较繁忙，我回到家里还要照顾两个小孩，自己的业余时间不多。
听说有牛人可以一边打麻将一边写报纸的社论，我没有这个本事，
**只好不打麻将，不看电视，少应酬， 每天坚持写一些东西，周末有时还跑到公司干活——**
周末在公司会碰到不少的同事，大家互相点点头，就忙各自的事情去了。
第一本书的30多万字，都是我用微软拼音输入法一个一个敲出来的，在这个过程中，还发现了输入法的一些bug；
同时Word 这个软件也崩溃了一两次，让我丢失了好几天的工作。
后来我把书稿发给了当时研究院的院长沈向洋博士征求意见，他很快给我回邮件，说「这是我看过的最有趣的软件开发的书！」
并答应给这本书写序言。他还希望能给我以后的每一本书都写序言。
在领导的鼓励下，我最后终于完成了这本书。

软件开发有一个阶段很少有人提及，叫“death march” 。
就像军队攻城，一队队士兵冒着炮火出击，伤亡无数，但是敌人的城堡仍旧岿然不动，火力看似依旧那么猛。
硝烟中，焦头烂额的指挥官还是下令新的士兵继续出发，开始又一轮的march。
在软件开发中也有类似的情形，就是你每天都加班写程序，改bug，但是bug不见少，第二天，第三天，下一周，下一个月......还是这样。
有军事家说过，最后的胜利往往产生于“再坚持一下”的努力之中。
经过无数大大小小的“再坚持一下”和“death march”，最后，有些军队破城而入；最后，有些软件成功发布；最后，有些书出版了。

  [1]: https://groups.google.com/g/pongba/c/3fWt2JyfnIw/m/qUOloyvmGFAJ
  [2]: https://www.cnblogs.com/geniusvczh/archive/2013/03/24/2978575.html
  [3]: https://www.douban.com/note/206395832/
  [4]: https://www.cnblogs.com/geniusvczh/archive/2011/12/16/2290808.html
  [5]: https://www.buaq.net/go-40279.html
  [6]: https://www.zhihu.com/question/26538403/answer/33147079
  [7]: http://www.ituring.com.cn/article/196609
  [8]: https://weibo.com/1401527553/Hz2wHelol?type=repost
  [9]: https://www.zhihu.com/question/373928721/answer/1039035765
  [10]: http://m.blog.chinaunix.net/uid-20724706-id-1886198.html
